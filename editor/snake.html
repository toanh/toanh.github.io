<html> 
<head> 
    <script src="js/skulpt.min.js" type="text/javascript"></script> 
    <script src="js/skulpt-stdlib.js" type="text/javascript"></script> 
    <script src="js/ace.js" type="text/javascript" charset="utf-8"></script>    
    <script src="js/FileSaver.min.js" type="text/javascript" charset="utf-8"></script>
    
    <style type="text/css" media="screen">
        #editor{
            box-sizing:border-box;
            border-top:2px solid #000;
            border-right:2px solid #000;
            border-left:2px solid #000;
            background-color:#50394c;
            color:#fff;
            padding:10px 10px 5px;
        }        
        #console {
            border: 10 px solid #d3d3d3;
            margin: auto;
            font-size: 14 px;
            width: 100%;
            height: 300 px;
            overflow-y: auto;
            background-color: #000;       
        }  
        .divider {
            background-color: #2F3129;       
        }  
    </style>
    
    <script type="text/javascript">   
        function save() {
            var code = ace.edit("editor").getValue();
            var file = new File([code], "my_code.py", {type: "text/plain;charset=utf-8"});
            saveAs(file);    
        }
        
        function outputf(n) {
            var text = "";
            var color = "rgb(255,255,255)";
            var bgcolor = "rgb(0,0,0)";
            var style;
            var weight;
                          
            i = 0;
            while (n.length > 0)
            {
                if (n[0] == "\u001b")
                {
                    i++;
                    if (text.length > 0)
                        pyConsole.appendChild(createColouredTextSpanElement(text, color, bgcolor, style, weight));                
                    text = "";
                    
                    var escPattern = /\[ (\d+);2;(\d+);(\d+);(\d+) m/;                          
                    var match = n.match(escPattern);
                    
                    if (typeof(match) !== 'undefined')
                    {
                        code = parseInt(match[1]);
                        if (code == 38)
                        {
                            color = "rgb(" + parseInt(match[2]) + "," + parseInt(match[3]) + "," + parseInt(match[4]) + ")"; 
                        }
                        else if (code == 48)
                        {
                            bgcolor = "rgb(" + parseInt(match[2]) + "," + parseInt(match[3]) + "," + parseInt(match[4]) + ")"; 
                        }
                        i = match.index + match[0].length;
                    }
                    n = n.substring(i);
                }
                else
                {
                    text += n[0];
                    n = n.substring(1);
                }                
            }
            if (text.length > 0)
                pyConsole.appendChild(createColouredTextSpanElement(text, color, bgcolor, style, weight));                           
            
            pyConsole.scrollTop = document.getElementById("console").scrollHeight;
        }
            
        function createColouredTextSpanElement(n, color, bgcolor, style, weight) {
            let t = document.createTextNode(n);        
            let e = document.createElement("span");
            e.style.color = color;        
            e.style.fontSize = "14pt";
            
            if (typeof(bgcolor) !== 'undefined')
            {
                e.style.backgroundColor = bgcolor;
            }
            
            if (typeof(style) !== 'undefined')
            {
            
            }
            
            if (typeof(weight) !== 'undefined')
            {
            
            }            
            e.appendChild(t);        
            return e;
        }
        
        function doGoto(name, code)
        {
            var destCode = code;
            if (name == "<stdin>")            
            {
                console.log(code);
                var labels = {};
                
                var blocks = [];
                                
                // grabbing all the blocks and their character indices in the code
                var casePattern = /case \d+:/g;                
                var matches = code.matchAll(casePattern);
                var numBlocks = 0;
                var start = 0;
                var end = 0;
                for (match of matches)
                {
                    if (numBlocks == 0)
                    {
                        start = match.index;
                    }
                    else
                    {
                        end = match.index;
                        blocks.push([start, end - start]);
                        start = end;
                        
                    }
                    numBlocks++;
                }
                if (numBlocks > 0)
                {
                    blocks.push([start, code.length - start - 1]);
                }
                
                // pass 1:
                // finding all the label blocks, grabbing their block numbers
                // and populating the lookup table with them
                for (i = 0; i < blocks.length; i++)
                {
                    block = code.substr(blocks[i][0], blocks[i][1]);
                    var blockNumberPattern = /case (\d+)/g;  
                    var blockNumberMatches = block.matchAll(blockNumberPattern);
                    for (blockNumberMatch of blockNumberMatches)
                    {
                        var labalNamePattern = /label (.+)/g;
                        var labalNameMatches = block.matchAll(labalNamePattern);
                        for (labalNameMatch of labalNameMatches)
                        {
                            labels[labalNameMatch[1].trim()] = blockNumberMatch[1];
                            
                            // deleting suspensions code associated with label code
                            var suspensionsPattern = /var \$loadname[\S\s]+?\$blk=(\d+);/g;
                            var suspensionsMatches = block.matchAll(suspensionsPattern);   

                            for (suspensionMatch of suspensionsMatches)
                            {
                                var nextBlock = parseInt(blockNumberMatch[1]) + 1;
                                var linenoPattern = /currLineNo = (\d+);/g;
                                var linenoMatches = block.matchAll(linenoPattern);   
                                for (linenoMatch of linenoMatches)                                
                                {
                                    var suspCode = "if (Sk.breakpoints('<stdin>.py'," + linenoMatch[1] + ",0)) {var $susp = $saveSuspension({data: {type: 'Sk.delay'}, resume: function() {}}, '<stdin>.py'," + linenoMatch[1] + ",0);$susp.$blk = " + nextBlock + ";$susp.optional = true;return $susp;}$blk=" + nextBlock + ";";
                                    destCode = destCode.replace(suspensionMatch[0], suspCode);      
                                }                                
                            }
                            
                            // deleting suspensions code in the next block too
                            if (i < blocks.length - 1)
                            {
                                block = code.substr(blocks[i + 1][0], blocks[i + 1][1]);
                                var suspensionsPattern = /if \(\$ret[\s\S]+=\$ret;/g;
                                var suspensionsMatches = block.matchAll(suspensionsPattern);   

                                for (suspensionMatch of suspensionsMatches)
                                {
                                    
                                    destCode = destCode.replace(suspensionMatch[0], "");                                                          
                                }                            
                            }
                        }
                    }
                }
                
                // pass 2:
                // fill in goto statements
                for (i = 0; i < blocks.length; i++)
                {
                    block = code.substr(blocks[i][0], blocks[i][1]);
                    var gotoPattern = patt2 = /\/\/\s+goto (.+)[\s\S]+/g;
                    var gotoMatches = block.matchAll(gotoPattern);
                    for (gotoMatch of gotoMatches)
                    {
                        var lineNo = labels[gotoMatch[1].trim()];
                        // replace everything from the case statement onwards (exclusively) with the blk jump
                        destCode = destCode.replace(gotoMatch[0], "$blk=" + lineNo + ";/* goto */continue;");
                    }
                }                                
            }
            
            return destCode;
        }

        function inputf(n) {
            inputPromise = new Promise((function(n, e) {                    
                        inputElement = document.createElement("span");
                        inputElement.setAttribute("contenteditable", "true");
                        inputElement.style.color = "rgb(255,255,255)";
                        inputElement.style.fontSize = "14pt";
                        inputElement.style.outlineStyle = "none";
                        pyConsole.appendChild(inputElement);
                        inputElement.focus();
                        inputElement.addEventListener("keyup", (function(e) {
                            e.preventDefault();
                            if (e.key ==="Enter") {
                                userResponse = inputElement.innerText.replace(/\n+$/, "");
                                inputElement.remove();
                                inputElement = null;
                                outputf(userResponse);
                                outputf("\n");
                                n(userResponse);
                            }
                        }))
                    }));
            return inputPromise;
        }
        
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        async function lineStepper(susp)
        {
            checkForStop();
            try {
                
                editor.gotoLine(susp.child.$lineno);            
                // don't pause on the first line
                if (just_run) just_run = false            
                else await sleep(1000);            

                // Return an already-resolved promise in this case
                return Promise.resolve(susp.resume());
            } catch(e) {
                return Promise.reject(e);
            }    
        }
        
        function checkForStop() {
            if (_stopped)
                throw 'stopped!';
        }
        
        function runSkulpt(stepRun) {
            var code = ace.edit("editor").getValue(); 
            
            editor.setReadOnly(true); 
            
            _stopped = false;
            
            // clear the console
            pyConsole.innerHTML = "";
            just_run = true;
            
            Sk.configure({
                output: outputf,
                inputfun: inputf,
                inputfunTakesPrompt: false,
                debugging: false, //stepRun ? true : false,
                killableWhile: true,
                //breakpoints: function() { return true; },
                __future__: Sk.python3
            });
            
            //Sk.onAfterCompile = doGoto;
                
            var handlers = {};
            handlers["*"] = checkForStop;            
            if (stepRun) {        
                editor.setTheme("ace/theme/gob");
                handlers["Sk.debug"] = lineStepper;
                handlers["Sk.delay"] = lineStepper;

            }
                           
            var e = Sk.misceval.asyncToPromise((function() {
                return Sk.importMainWithBody("<stdin>", true, code, true)})
                , handlers);
            
            e.catch((function(err) {
                if (err.message) {
                   outputf(err.message + "\n");
                   outputf(err.stack);
                   if (err.nativeError) {
                       outputf(err.nativeError.message + "\n");
                       outputf(err.nativeError.stack);
                   }
                }
                else {
                   outputf(err.toString() + "\n");
                   if (err.stack)
                   {
                       outputf(err.stack);
                   }                   
            }}));
            e.finally((function() { 
                stopSkulpt(); 
            } ));
        }
        
        function stopSkulpt() {
            editor.setReadOnly(false); 
            editor.setTheme("ace/theme/monokai");
            just_run = false;
         
        }
        
        function stopEditor()
        {
            _stopped = true;
            if (inputElement != null)
            {
                stopSkulpt();
                userResponse = inputElement.innerText.replace(/\n+$/, "");
                                                inputElement.remove();
                                                outputf(userResponse);
                                                outputf("\n"); 
                // TODO: fold this into the main promise/catch process?
                inputElement = null;
                outputf("stopped");
                throw "stopped";
            }           
        }
    </script>     
</head> 

<body> 
 
    <div id="container" style = "width:1024px; margin: 0 auto">
        <h1 style="text-align: center">Coding Exercise # 1</h3>     
        <form style = "width:400px; margin: 20px auto;text-align: center"> 
            <button type="button" onclick="runSkulpt(false);">Run</button> 
            <button type="button" onclick="runSkulpt(true);">Step-Run</button> 
            <button type="button" onclick="stopEditor();">Stop</button>
            <button type="button" onclick="save();">Save</button> 
        </form>  
        <div style = "display: flex; flex-direction:row;">
            <div style = "width: 75%; border: 1px solid black">
                <div id="editor" style="height: 400px">from pyangelo import *
from random import *

print(HIGHLIGHT_WHITE + GREEN + "hello " + RED + "world" + BLUE + "!")
blockSize = 20
font = str(blockSize) + "px consolas"

score = 0
gameState = 'intro'

while True:
    clearScreen()
    drawText("Snake!", 120, 40, font, RED)
    drawText("Score: " + str(score), 100, 65, font)
    
    # draw the border
    drawRect(18, 98, \
             290, 428, 1, GREEN)    
    
    if gameState == 'intro':
        drawText("Press 'ENTER' to start", 40, 285, font)
        if isKeyReleased('Enter'):
            gameState = 'play'
            # Initializing values
            score = 0
            speed = 0.0002
            
            # Initial snake co-ordinates
            snake = [[4 * blockSize, 15 * blockSize], \
                     [3 * blockSize ,15 * blockSize], \
                     [2 * blockSize, 15 * blockSize]]
            food = [7 * blockSize, 13 * blockSize]    
            dx = 1
            dy = 0
            progress = 0            
    elif gameState == 'play':
        # check for keys
        if isKeyPressed('d'):
            dx = 1
            dy = 0
        elif isKeyPressed('a'):
            dx = -1
            dy = 0
        elif isKeyPressed('s'):
            dx = 0
            dy = 1
        elif isKeyPressed('w'):
            dx = 0
            dy = -1
        progress = progress + speed
        if progress >= 1.0:
            progress = 1.0 - progress
            # move the snake body
            for n in range(len(snake) - 1, 0, -1):
              snake[n][0] = snake[n - 1][0]
              snake[n][1] = snake[n - 1][1]      
            snake[0][0] = snake[0][0] + dx * blockSize
            snake[0][1] = snake[0][1] + dy * blockSize

        # draw food
        drawText("🍓", food[0], food[1], font)
        # draw head
        drawText("😀", snake[0][0], snake[0][1], font)
        # draw body
        for n, body in enumerate(snake[1:]):
            drawText("📀", body[0], body[1], font)

        if snake[0][0] <= 18 or \
           snake[0][1] <= 100 or \
           snake[0][0] >= 300 or \
           snake[0][1] >= 523: 
            gameState = 'intro'            

        # did the snake eat itself?
        if snake[0] in snake[1:]:
            gameState = 'intro'
        
        # snake eats food
        if snake[0] == food:
          # grow snake
          snake.append([snake[-1][0], snake[-1][1]])
          score += 100
          speed += 0.000025
          # generate new food
          # can't be located in the snake
          while food in snake:
            foodX = randint(1, 14) * blockSize
            foodY = randint(6, 26) * blockSize
            food = [foodX, foodY]         

                </div>
                <div class="divider" style="height: 10px"></div>    
                <pre id="console" style="height: 140px" onfocus="if (inputElement != null) inputElement.focus();"></pre>        
            </div>
            <div>
                <canvas id="pyangelo" height = 550 width = 326 style="border: 1px solid black; flex: 1 1 0px;" tabindex='1'></canvas>
            </div>
        </div>
        
    </div>
    
    <!---- setting up global vars for the editor and console etc. ----->
    <script>
        var pyConsole = document.getElementById("console"); 
        
        var editor = ace.edit("editor");
        editor.setTheme("ace/theme/monokai");
        editor.session.setMode("ace/mode/python");        
        editor.setOptions({  
          fontSize: "14pt"
        });        
        editor.setHighlightActiveLine(true);
        
        var just_run = false;
        var _stopped = false;
        var inputElement = null;
     
    </script>    

</body> 

</html> 